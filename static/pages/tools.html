<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>TextUtil</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <script charset="UTF-8" id="LA_COLLECT" src="js/sdk.51.la_js-sdk-pro.min.js"></script>
    <script>LA.init({id: "3JacvsQODVWrNK9p", ck: "3JacvsQODVWrNK9p", autoTrack: true, hashMode: true})</script>

    <script src="js/http_cdn.jsdelivr.net_npm_jquery@3.5.1_dist_jquery.slim.js"></script>
    <link rel="stylesheet" href="css/http_cdn.jsdelivr.net_npm_bootstrap@4.6.2_dist_css_bootstrap.css">
    <script src="js/http_cdn.jsdelivr.net_npm_bootstrap@4.6.2_dist_js_bootstrap.bundle.js"></script>
    <script src="js/http_cdn.jsdelivr.net_npm_xlsx_dist_xlsx.full.min.js"></script>
    <script src="js/http_cdn.jsdelivr.net_npm_file-saver@2.0.5_dist_FileSaver.js"></script>
    <!-- CodeMirror 5 用于 JSON 高亮与自动缩进 -->
    <link rel="stylesheet" href="js/codemirror/lib/codemirror.css">
    <link rel="stylesheet" href="js/codemirror/theme/neo.css">
    <script src="js/codemirror/lib/codemirror.js"></script>
    <script src="js/codemirror/mode/javascript/javascript.js"></script>
    <script src="js/codemirror/addon/edit/closebrackets.js"></script>
    <script src="js/codemirror/addon/edit/matchbrackets.js"></script>
    <script src="js/codemirror/addon/display/placeholder.js"></script>
    <!-- CodeMirror 额外功能：当前行高亮与代码折叠（本地化） -->
    <link rel="stylesheet" href="js/codemirror/addon/fold/foldgutter.css">
    <script src="js/codemirror/addon/selection/active-line.js"></script>
    <script src="js/codemirror/addon/fold/foldcode.js"></script>
    <script src="js/codemirror/addon/fold/foldgutter.js"></script>
    <script src="js/codemirror/addon/fold/brace-fold.js"></script>
    <script src="js/codemirror/addon/fold/comment-fold.js"></script>
    <script>
        // 全局变量
        const APP_VERSION = '4.0.0';
        
        $(function () {
            $('[data-toggle="tooltip"]').tooltip();
        });
    </script>
</head>
<body>
<style>
    /* 主题变量 */
    :root {
        --bg: #ffffff;
        --text: #212529;
        --muted: #6c757d;
        --card-bg: #ffffff;
        --card-header-bg: #f8f9fa;
        --border: #dee2e6;
        --input-bg: #ffffff;
        --input-text: #212529;
        --dropdown-bg: #ffffff;
        --btn-bg: transparent;
        --btn-text: #343a40;
        --btn-border: #343a40;
        --toggle-bg: #F0F0F0;
        --toggle-slider-bg: #ffffff;
        --editor-bg: #ffffff;
        --editor-gutter-bg: #f8f9fa;
        --editor-cursor: #111111;
        --toggle-active-text: #000000;
        --toggle-inactive-text: #666666;
    }

    [data-theme="dark"] {
        --bg: #121212;
        --text: #e9ecef;
        --muted: #adb5bd;
        --card-bg: #1b1b1b;
        --card-header-bg: #1f1f1f;
        --border: #2b2b2b;
        --input-bg: #202020;
        --input-text: #e9ecef;
        --dropdown-bg: #202020;
        --btn-bg: transparent;
        --btn-text: #e9ecef;
        --btn-border: #495057;
        --toggle-bg: #2a2a2a;
        --toggle-slider-bg: #3b3b3b;
        --editor-bg: #1e1e1e;
        --editor-gutter-bg: #252525;
        --editor-cursor: #e9ecef;
        --toggle-active-text: #ffffff;
        --toggle-inactive-text: #adb5bd;
    }

    /* 全局基色覆盖 */
    html, body {
        background-color: var(--bg);
        color: var(--text);
    }

    .card { background-color: var(--card-bg); border-color: var(--border); }
    .card-header { background-color: var(--card-header-bg); border-color: var(--border); color: var(--text); }
    .form-control, textarea { background-color: var(--input-bg); color: var(--input-text); border-color: var(--border); }
    /* 暗色下输入框聚焦不变白 */
    [data-theme="dark"] .form-control:focus,
    [data-theme="dark"] textarea:focus {
        background-color: var(--input-bg);
        color: var(--input-text);
        border-color: var(--btn-border);
        box-shadow: 0 0 0 0.2rem rgba(108,117,125,0.25);
    }
    .input-group-text { background-color: var(--card-header-bg); color: var(--text); border-color: var(--border); }
    .dropdown-menu { background-color: var(--dropdown-bg); }
    .dropdown-item { color: var(--text); }
    .dropdown-item:hover { background-color: rgba(108,117,125,0.15); }
    .stats-text { color: var(--muted); }

    /* 文件选择框（Bootstrap custom-file）暗色兼容 */
    .custom-file-label {
        background-color: var(--input-bg);
        color: var(--input-text);
        border-color: var(--border);
    }
    .custom-file-input:focus ~ .custom-file-label,
    .custom-file-input:hover ~ .custom-file-label {
        color: var(--input-text);
        background-color: var(--input-bg);
        border-color: var(--btn-border);
        box-shadow: 0 0 0 0.2rem rgba(108,117,125,0.25);
    }
    .custom-file-label::after {
        background-color: var(--card-header-bg);
        color: var(--text);
        border-left: 1px solid var(--border);
    }

    /* 按钮覆盖（以 outline-dark 为主） */
    .btn-outline-dark {
        color: var(--btn-text);
        border-color: var(--btn-border);
        background-color: var(--btn-bg);
    }
    .btn-outline-dark:hover,
    .btn-outline-dark:focus {
        color: var(--text);
        background-color: rgba(108,117,125,0.25);
        border-color: var(--btn-border);
    }

    .no-padding {
        padding-left: 0 !important;
        padding-right: 0 !important;
    }

    /* 切换开关样式 */
    .toggle-switch {
        display: flex;
        background-color: var(--toggle-bg);
        border-radius: 0.25rem;
        padding: 2px;
        position: relative;
        width: 100%;
        max-width: 560px;
        height: 28px;
        margin: 0.25rem auto 0;
        overflow: hidden;
    }

    /* 滑动背景 */
    .toggle-slider {
        position: absolute;
        top: 2px;
        left: 4px;
        width: calc(25% - 8px);
        height: 24px;
        background-color: var(--toggle-slider-bg);
        border-radius: 0.25rem;
        box-shadow: 0 2px 12px rgba(0, 0, 0, 0.25);
        transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        z-index: 0;
    }

    .toggle-slider.slide-right {
        transform: translateX(100%);
    }

    .toggle-option {
        flex: 1;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 0.25rem;
        cursor: pointer;
        transition: color 0.3s ease;
        font-size: 1.125rem;
        font-weight: 500;
        position: relative;
        z-index: 1;
        user-select: none;
        white-space: nowrap;
    }

    .toggle-option.active { color: var(--toggle-active-text); }
    .toggle-option.inactive { color: var(--toggle-inactive-text); }

    .toggle-option:hover {
        opacity: 0.8;
    }

    /* 区分大小写按钮激活状态样式 */
    .btn-outline-secondary.active {
        background-color: #495057 !important;
        border-color: #495057 !important;
        color: white !important;
    }

    /* 隐藏原有的Bootstrap标签样式 */
    .nav-tabs {
        display: none;
    }

    /* 集合运算页面样式优化 */
    .card-header {
        border-bottom: 1px solid var(--border);
        border-radius: 0.25rem 0.25rem 0 0 !important;
        padding: 0.5rem 0.75rem;
        font-size: 1rem;
        font-weight: 400;
        text-align: center;
    }

    /* 文本统计样式 */
    .stats-text {
        font-size: 0.75rem; /* 小号字体 */
    }

    /* 去除文本处理页卡片底部边框线 */
    #text .card {
        border-bottom: 0 !important;
        border-right: 0 !important;
    }
    #text .card:first-child {
        border-left: 0 !important;
    }

    /* 去除 JSON处理 页卡片边框线（与文本处理一致） */
    #json-operation .card {
        border-bottom: 0 !important;
        border-right: 0 !important;
    }
    #json-operation .card:first-child {
        border-left: 0 !important;
    }

    /* 去除大爆炸页卡片边框线（与文本处理一致） */
    #bigbang .card {
        border-bottom: 0 !important;
        border-right: 0 !important;
    }
    #bigbang .card:first-child {
        border-left: 0 !important;
    }

    /* CodeMirror 在 JSON处理 中的高度与边框（与 form-control 视觉接近） */
    #json-operation .CodeMirror {
        height: 370px;
        border: 1px solid var(--border);
        border-radius: 0.25rem;
        background-color: var(--editor-bg);
        color: var(--text);
    }
    /* CodeMirror 当前行高亮（仅 JSON处理 页） */
    #json-operation .CodeMirror-activeline-background { 
        background: rgba(108,117,125,0.15); 
    }
    #json-operation .CodeMirror-activeline-gutter { 
        background: rgba(108,117,125,0.15); 
    }
    /* 正确为行号预留独立 gutter，避免与文本重叠 */
    /* 让 CodeMirror 自行计算 gutter 宽度，避免与正文错位 */
    /* 让 CodeMirror 自行设置 gutters 宽度，避免覆盖导致的遮挡 */
    /* 移除强制 width，交由 JS 计算精确像素 */
    #json-operation .CodeMirror-linenumbers {
        width: auto;
        text-align: right;
        padding-right: 4px;
    }
    /* 恢复行内最小左内边距，避免初始光标贴到 gutter */
    #json-operation .CodeMirror-lines pre {
        padding-left: 0;
    }
    /* 占位符文本右移，避免与行号区域重叠 */
    #json-operation .CodeMirror .CodeMirror-placeholder {
        padding-left: 0;
        color: var(--muted); /* 与占位提示风格一致 */
    }
    /* 隐藏所有 gutters（行号/折叠栏），并去除占位宽度 */
    #json-operation .CodeMirror-gutters {
        display: none !important;
        width: 0 !important;
    }

    /* CodeMirror 常规覆盖（行内/游标） */
    .CodeMirror-cursor { border-left: 1px solid var(--editor-cursor); }
    .cm-s-neo.CodeMirror { background-color: var(--editor-bg); color: var(--text); }
    .cm-s-neo .CodeMirror-gutters { background-color: var(--editor-gutter-bg); border-right: 1px solid var(--border); }

    /* 集合运算输入卡片头部：左侧标题 + 右侧统计 */
    #set-operation .card-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        text-align: left;
    }

    /* 大爆炸样式 */
    #bigbang .input-area {
        margin-bottom: 0.5rem;
    }
    
    /* 大爆炸输入框深黑色边框样式 */
    #bigbangInput {
        border: 2px solid #000000;
        border-radius: 0.25rem;
    }
    
    #bigbangInput:focus {
        border-color: #000000;
        box-shadow: 0 0 0 0.2rem rgba(0, 0, 0, 0.2);
        outline: none;
    }
    
    #bigbang .word-container {
        border: 1px solid var(--border);
        background-color: var(--input-bg);
        min-height: 400px;
        padding: 15px;
        border-radius: 0.25rem;
        overflow-y: auto;
        max-height: 400px;
    }
    
    #bigbang .word-tag {
        display: inline-block;
        background-color: transparent;
        color: var(--text);
        border: 1px solid var(--border);
        padding: 6px 12px;
        margin: 4px;
        border-radius: 3px;
        cursor: pointer;
        user-select: none;
        transition: all 0.2s;
        font-size: 14px;
    }
    
    #bigbang .word-tag:hover {
        background-color: rgba(108, 117, 125, 0.1);
        transform: translateY(-1px);
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }
    
    #bigbang .word-tag.selected {
        background-color: #000000;
        color: #ffffff;
        border-color: #000000;
    }
    
    #bigbang .result-area {
        border: 1px solid var(--border);
        background-color: var(--input-bg);
        min-height: 400px;
        padding: 0.375rem 0.75rem;
        border-radius: 0.25rem;
        color: var(--text);
        white-space: pre-wrap;
        word-wrap: break-word;
        overflow-y: auto;
        max-height: 400px;
        font-family: inherit;
        font-size: 1rem;
        line-height: 1.5;
    }

    #target {
        white-space: pre-wrap;
        word-wrap: break-word;
    }

    #target .filter-highlight {
        color: #dc3545;
        background-color: rgba(220, 53, 69, 0.1);
        padding: 0 2px;
        border-radius: 2px;
    }

</style>

<div class="container-fluid col-xl-8 mt-4">
    <div class="alert alert-danger mt-1" role="alert">
        <a href="https://sunkz.top/posts/文本工具箱上架utools啦/" class="alert-link">工具箱已经上架到 utools 了, 点击查看详情</a>
    </div>

    <!-- 标签与主题切换同排 -->
    <div class="d-flex align-items-center mt-0">
        <div class="toggle-switch" id="toggleSwitch">
            <div class="toggle-slider" id="toggleSlider"></div>
            <div class="toggle-option active" data-target="text" onclick="switchTab('text')">文本处理</div>
            <div class="toggle-option inactive" data-target="json-operation" onclick="switchTab('json-operation')">JSON处理</div>
            <div class="toggle-option inactive" data-target="set-operation" onclick="switchTab('set-operation')">集合运算</div>
            <div class="toggle-option inactive" data-target="bigbang" onclick="switchTab('bigbang')">大爆炸</div>
        </div>
    </div>

    <!-- 标签内容 -->
    <div class="tab-content no-padding" id="textTabContent">
        <!-- 第一个标签页内容 -->
        <div class="tab-pane fade show active no-padding" id="text" role="tabpanel" aria-labelledby="text-tab">
            <div class="card-group mt-1">
                <div class="card mr-1">
                    <textarea id="source" rows="15" class="form-control" placeholder="请输入文本"></textarea>
                    <div class="d-flex justify-content-end px-2 py-1">
                        <small id="source-stats" class="stats-text">0 行 · 0 字符</small>
                    </div>
                </div>
                <div class="card">
                    <div id="target" contenteditable="true" class="form-control" style="min-height: 370px; overflow-y: auto;"></div>
                    <div class="d-flex justify-content-end px-2 py-1">
                        <small id="target-stats" class="stats-text">0 行 · 0 字符</small>
                    </div>
                </div>
            </div>
            <div class="btn-group" role="group" aria-label="Basic example">
                <button type="button" class="btn btn-secondary" title="清空输入框/输出框" onclick="doClear()">清空</button>
            </div>
            <div class="btn-group" role="group" aria-label="Basic example">
                <button type="button" class="btn btn-secondary" data-toggle="tooltip" title="复制结果到输入框" onclick="overwrite()">覆盖</button>
            </div>
            <div class="btn-group" role="group" aria-label="Basic example">
                <button type="button" class="btn btn-outline-dark" onclick="reverse()">反转</button>
            </div>
            <div class="btn-group" role="group" aria-label="Basic example">
                <button type="button" class="btn btn-outline-dark" onclick="calculator()">计算器</button>
            </div>
            <div class="btn-group" role="group" aria-label="Basic example">
                <button type="button" class="btn btn-outline-dark" onclick="toUpperCase()">转大写</button>
                <button type="button" class="btn btn-outline-dark" onclick="toLowerCase()">小写</button>
            </div>
            <div class="btn-group" role="group" aria-label="Basic example">
                <button type="button" class="btn btn-outline-dark" onclick="toCamelCase()">转驼峰</button>
                <button type="button" class="btn btn-outline-dark" onclick="toSnakeCase()">下划线</button>
            </div>
            <div class="btn-group" role="group" aria-label="Basic example">
                <button type="button" class="btn btn-outline-dark" onclick="base64Encode()">Base64编码</button>
                <button type="button" class="btn btn-outline-dark" onclick="base64Decode()">解码</button>
            </div>
            <div class="btn-group" role="group" aria-label="Basic example">
                <button type="button" class="btn btn-outline-dark" onclick="urlEncode()">url编码</button>
                <button type="button" class="btn btn-outline-dark" onclick="urlDecode()">解码</button>
            </div>
            <div class="btn-group mt-1" role="group" aria-label="Basic example">
                <button type="button" class="btn btn-outline-dark" data-toggle="tooltip" title="各种常见时间格式,为空时默认当前时间" onclick="toTimestamp()">转时间戳</button>
                <button type="button" class="btn btn-outline-dark" data-toggle="tooltip" title="为空时默认当前时间戳" onclick="toDate()">转日期</button>
            </div>
            <div class="btn-group mt-1" role="group" aria-label="Basic example">
                <span class="input-group-text" data-toggle="tooltip" title="多行文本处理">多行</span>
                <button type="button" class="btn btn-outline-dark" onclick="ascending()">升序</button>
                <button type="button" class="btn btn-outline-dark" onclick="descending()">降序</button>
                <button type="button" class="btn btn-outline-dark" onclick="distinct()">去重</button>
                <button type="button" class="btn btn-outline-dark" onclick="wordFrequency()">词频</button>
                <button type="button" class="btn btn-outline-dark" onclick="sum()" data-toggle="tooltip" title="多行数字求和">求和</button>
                <button type="button" class="btn btn-outline-dark" onclick="average()" data-toggle="tooltip" title="多行数字求平均">平均</button>
            </div>
            <div class="btn-group mt-1" role="group" aria-label="Basic example">
                <button type="button" id="merge-empty-btn" class="btn btn-outline-dark" onclick="mergeSymbol('empty')">合并x,</button>
                <button type="button" id="merge-single-btn" class="btn btn-outline-dark" onclick="mergeSymbol('single')">'x',</button>
                <button type="button" id="merge-double-btn" class="btn btn-outline-dark" onclick="mergeSymbol('double')">"x",</button>
            </div>
            <div class="btn-group mt-1" role="group" aria-label="Basic example">
                <button type="button" id="split-btn" class="btn btn-outline-dark" onclick="splitlines(',')">分割,</button>
                <button type="button" class="btn btn-outline-dark dropdown-toggle dropdown-toggle-split" data-toggle="dropdown" aria-expanded="false">
                    <span class="sr-only">分割item</span>
                </button>
                <div class="dropdown-menu" aria-labelledby="split-btn">
                    <a class="dropdown-item" href="#" onclick="splitlines(',')">分割,</a>
                    <a class="dropdown-item" href="#" onclick="splitlines('，')">分割，</a>
                    <a class="dropdown-item" href="#" onclick="splitlines(' ')">分割空格</a>
                    <a class="dropdown-item" href="#" onclick="splitlines('\\t')">分割\t</a>
                    <a class="dropdown-item" href="#" onclick="splitlines(';')">分割;</a>
                    <a class="dropdown-item" href="#" onclick="splitlines(':')">分割:</a>
                    <a class="dropdown-item" href="#" onclick="splitlines('|')">分割|</a>
                    <a class="dropdown-item" href="#" onclick="splitlines('\\n')">分割\n</a>
                    <a class="dropdown-item" href="#" onclick="splitlines('、')">分割、</a>
                    <a class="dropdown-item" href="#" onclick="splitlines('.')">分割.</a>
                </div>
            </div>
            <!-- 过滤和提取列功能区域 -->
            <div class="input-group mt-1">
                <div class="input-group-prepend">
                    <div class="btn-group">
                        <button type="button" class="btn btn-outline-dark" id="txtFilterBtn" data-toggle="tooltip" title="多行文本过滤 支持逻辑表达式: || 或, && 与, ! 非, () 分组">过滤</button>
                        <button type="button" class="btn btn-outline-dark dropdown-toggle dropdown-toggle-split" data-toggle="dropdown" aria-expanded="false">
                            <span class="sr-only">过滤item</span>
                        </button>
                        <div class="dropdown-menu" aria-labelledby="txtFilterBtn">
                            <a class="dropdown-item" href="#" onclick="switchToFilterMode()">过滤</a>
                            <a class="dropdown-item" href="#" onclick="switchToExtractMode()">提取</a>
                            <a class="dropdown-item" href="#" onclick="switchToReplaceMode()">替换</a>
                            <a class="dropdown-item" href="#" onclick="switchToJoinMode()">拼接</a>
                        </div>
                    </div>
                </div>
                
                <!-- 过滤输入区域 -->
                <div id="filterInputGroup" class="flex-grow-1">
                    <input type="text" id="textFilterInput" class="form-control" placeholder="多行文本过滤 支持逻辑表达式: a || b, (a || b) && c, (a || b) && (c || !d)" aria-label="Text filter input">
                </div>
                
                <!-- 提取列输入区域 -->
                <div id="extractInputGroup" class="flex-grow-1" style="display: none;">
                    <div class="input-group">
                        <input type="text" id="extractDelimiter" class="form-control" style="width: 33.333%;" placeholder="请输入分割符" aria-label="Extract delimiter">
                        <input type="text" id="extractColumns" class="form-control" style="width: 66.666%;" placeholder="请输入需要提取的列（多个列用逗号分隔，如：1,3,5）" aria-label="Extract columns">
                    </div>
                </div>
                
                <!-- 替换功能区域 -->
                <div id="replaceInputGroup" class="flex-grow-1" style="display: none;">
                    <div class="input-group">
                        <input type="text" id="replaceFrom" class="form-control" style="width: 50%;" placeholder="请输入要替换的内容" aria-label="Replace from">
                        <input type="text" id="replaceTo" class="form-control" style="width: 50%;" placeholder="请输入替换后的内容" aria-label="Replace to">
                    </div>
                </div>
                
                <!-- 拼接功能区域 -->
                <div id="joinInputGroup" class="flex-grow-1" style="display: none;">
                    <div class="input-group">
                        <input type="text" id="joinPrefix" class="form-control" style="width: 25%;" placeholder="请输入前缀" aria-label="Join prefix">
                        <input type="text" id="joinSuffix" class="form-control" style="width: 25%;" placeholder="请输入后缀" aria-label="Join suffix">
                    </div>
                </div>
                
                <!-- 右侧按钮组 -->
                <div class="input-group-append">
                    <button type="button" class="btn btn-outline-secondary" id="toggleCaseBtn" title="区分大小写：开启=区分 关闭=不区分" data-toggle="tooltip">Aa</button>
                </div>
            </div>
        </div>

        <!-- 第二个标签页内容 -->
        <div class="tab-pane fade no-padding" id="json-operation" role="tabpanel" aria-labelledby="json-tab">
            <div class="card-group mt-1">
                <div class="card mr-1">
                    <textarea id="json_source" rows="15" class="form-control" placeholder="[\"请输入JSON文本\"]"></textarea>
                    <div class="d-flex justify-content-end px-2 py-1">
                        <small id="json_source-stats" class="stats-text">0 行 · 0 字符</small>
                    </div>
                </div>
                <div class="card">
                    <textarea id="json_target" rows="15" class="form-control"></textarea>
                    <div class="d-flex justify-content-end px-2 py-1">
                        <small id="json_target-stats" class="stats-text">0 行 · 0 字符</small>
                    </div>
                </div>
            </div>
            <div class="btn-group" role="group" aria-label="Basic example">
                <button type="button" class="btn btn-secondary" title="清空输入框/输出框" onclick="doJsonClear()">清空</button>
            </div>
            <div class="btn-group" role="group" aria-label="Basic example">
                <button type="button" class="btn btn-secondary" data-toggle="tooltip" title="复制结果到输入框" onclick="overwriteJson()">覆盖</button>
            </div>
            <div class="btn-group" role="group" aria-label="Basic example">
                <button type="button" class="btn btn-outline-dark" onclick="jsonFormat()">格式化</button>
            </div>
            <div class="btn-group" role="group" aria-label="Basic example">
                <button type="button" class="btn btn-outline-dark" onclick="jsonFold()">压缩</button>
                <button type="button" class="btn btn-outline-dark" onclick="jsonUnfold()">展开</button>
            </div>
            <div class="btn-group" role="group" aria-label="Basic example">
                <button type="button" class="btn btn-outline-dark" data-toggle="tooltip" title="将带转义符的JSON字符串转为正常JSON" onclick="jsonUnescape()">toJson</button>
                <button type="button" class="btn btn-outline-dark" data-toggle="tooltip" title="将JSON转成带转义符号的字符串" onclick="escapeJson()">toString</button>
            </div>
            <div class="btn-group" role="group" aria-label="Basic example">
                <button type="button" class="btn btn-outline-dark" data-toggle="tooltip" title="JSON数组" onclick="jsonToExcel()">转excel</button>
            </div>
            <div class="input-group mt-1">
                <div class="input-group-prepend">
                    <span class="input-group-text" id="jsOptBtn" data-toggle="tooltip">JSONPath this</span>
                    <button type="button" class="btn btn-outline-secondary dropdown-toggle dropdown-toggle-split" data-toggle="dropdown" aria-expanded="false">
                        <span class="sr-only">jsonOpt</span>
                    </button>
                    <div class="dropdown-menu">
                        <a class="dropdown-item" href="#" id="modeJsonPath">模式一 : JSONPath</a>
                        <a class="dropdown-item" href="#" id="modeFieldExtract">模式二 : JSON数组字段提取</a>
                    </div>
                </div>
                <input type="text" id="jsonModeInput" class="form-control"  placeholder=".key.subKey、[0][1]、.map(x=>x.val)、.filer(x=>x.val>20) " aria-label="Text input with segmented dropdown button">
            </div>
            <div class="input-group mt-1">
                <div class="custom-file mr-2">
                    <input type="file" class="custom-file-input" id="file" name="file" aria-describedby="upload" accept=".xlsx, .xls">
                    <label class="custom-file-label" for="file" data-browse="EXCEL转JSON" id="fileLabel">请选择EXCEL文件</label>
                </div>
                <div class="custom-file">
                    <input type="file" class="custom-file-input" id="mfile" name="mfile" aria-describedby="upload" accept=".xlsx, .xls" multiple>
                    <label class="custom-file-label" for="mfile" data-browse="EXCEL合并" id="mfileLabel">请选择EXCEL文件, 表头需要相同</label>
                </div>
            </div>
        </div>

        <!-- 第三个标签页内容 -->
        <div class="tab-pane fade no-padding" id="set-operation" role="tabpanel" aria-labelledby="set-tab">
            <div class="card-group mt-1">
                <div class="card mr-1">
                    <div class="card-header">
                        <span>文本A</span>
                        <small id="set-tab-source-1-stats" class="stats-text">0 行 · 0 字符</small>
                    </div>
                    <textarea id="set-tab-source-1" rows="15" class="form-control" placeholder="请输入文本A"></textarea>
                </div>
                <div class="card">
                    <div class="card-header">
                        <span>文本B</span>
                        <small id="set-tab-source-2-stats" class="stats-text">0 行 · 0 字符</small>
                    </div>
                    <textarea id="set-tab-source-2" rows="15" class="form-control" placeholder="请输入文本B"></textarea>
                </div>
            </div>

            <div class="text-center mt-1">
                <button type="button" class="btn btn-outline-dark" onclick="setOperation()" style="border-radius: 0.25rem; padding: 0.375rem 1.5rem;">运算</button>
            </div>

            <div class="card-group mt-1 mb-1">
                <div class="card mr-1">
                    <div class="card-header">
                        <span>A∪B</span>
                        <small id="set-tab-target-1-stats" class="stats-text">0 行 · 0 字符</small>
                    </div>
                    <textarea id="set-tab-target-1" rows="16" class="form-control"></textarea>
                </div>
                <div class="card mr-1">
                    <div class="card-header">
                        <span>A∩B</span>
                        <small id="set-tab-target-2-stats" class="stats-text">0 行 · 0 字符</small>
                    </div>
                    <textarea id="set-tab-target-2" rows="16" class="form-control"></textarea>
                </div>
                <div class="card mr-1">
                    <div class="card-header">
                        <span>A-B</span>
                        <small id="set-tab-target-3-stats" class="stats-text">0 行 · 0 字符</small>
                    </div>
                    <textarea id="set-tab-target-3" rows="16" class="form-control"></textarea>
                </div>
                <div class="card">
                    <div class="card-header">
                        <span>B-A</span>
                        <small id="set-tab-target-4-stats" class="stats-text">0 行 · 0 字符</small>
                    </div>
                    <textarea id="set-tab-target-4" rows="16" class="form-control"></textarea>
                </div>
            </div>
        </div>
        <!-- 第四个标签页内容 - 大爆炸 -->
        <div class="tab-pane fade no-padding" id="bigbang" role="tabpanel" aria-labelledby="bigbang-tab">
            <div class="card-group mt-1">
                <div class="card mr-1">
                    <div id="wordContainer" class="word-container"></div>
                    <div class="d-flex justify-content-end px-2 py-1">
                        <small id="bigbang-source-stats" class="stats-text">0 个元素</small>
                    </div>
                </div>
                <div class="card">
                    <div id="resultArea" class="result-area"></div>
                    <div class="d-flex justify-content-end px-2 py-1">
                        <small id="bigbang-target-stats" class="stats-text">0 行 · 0 字符</small>
                    </div>
                </div>
            </div>
            <div class="input-group mt-1">
                <input type="text" id="bigbangInput" class="form-control" placeholder="请粘贴或输入文本..." aria-label="Bigbang input">
            </div>
            <div class="btn-group mt-1" role="group" aria-label="Split mode">
                <span class="input-group-text">分割模式</span>
                <button type="button" class="btn btn-outline-dark" id="splitByWord" onclick="bigbangSplitMode('word')">分词</button>
                <button type="button" class="btn btn-outline-dark" id="splitByChar" onclick="bigbangSplitMode('char')">分字</button>
            </div>
            <div class="btn-group mt-1" role="group" aria-label="Actions">
                <button type="button" class="btn btn-outline-dark" onclick="bigbangClearInput()">清空输入</button>
                <button type="button" class="btn btn-outline-dark" onclick="bigbangClearSelection()">清空选择</button>
                <button type="button" class="btn btn-outline-dark" onclick="bigbangCopyResult()">复制结果</button>
            </div>
        </div>
    </div>
</div>
<script>

    // 初始化 CodeMirror 编辑器（JSON 高亮、自动缩进）
    if (window.CodeMirror) {
        window.jsonSourceEditor = CodeMirror.fromTextArea(document.getElementById('json_source'), {
            mode: {name: 'javascript', json: true},
            lineNumbers: false,
            indentUnit: 2,
            tabSize: 2,
            smartIndent: true,
            matchBrackets: true,
            autoCloseBrackets: true,
            lineWrapping: true,
            theme: 'neo',
            placeholder: '["请输入JSON文本"]',
            styleActiveLine: true,
            gutters: [],
            foldGutter: false
        });
        window.jsonTargetEditor = CodeMirror.fromTextArea(document.getElementById('json_target'), {
            mode: {name: 'javascript', json: true},
            lineNumbers: false,
            indentUnit: 2,
            tabSize: 2,
            smartIndent: true,
            matchBrackets: true,
            autoCloseBrackets: true,
            lineWrapping: true,
            theme: 'neo',
            styleActiveLine: true,
            gutters: [],
            foldGutter: false
        });

        // 编辑时更新统计与联动
        jsonSourceEditor.on('change', function () {
            updateStats('json_source');
            const jsonModeInput = document.getElementById('jsonModeInput');
            if (jsonModeInput && jsonModeInput.value.trim() !== '') {
                if (window.currentJsonMode === 'field') {
                    updateJsonFieldExtractCombined();
                } else if (window.currentJsonMode === 'jsonpath') {
                    updateJsonPathEval();
                }
            }
        });
        jsonTargetEditor.on('change', function () { updateStats('json_target'); });
    }

    // 封装：获取/设置 JSON 源与目标（兼容 CodeMirror 与原 textarea）
    function getJsonSource() {
        return window.jsonSourceEditor ? window.jsonSourceEditor.getValue() : document.getElementById('json_source').value;
    }
    function setJsonSource(value) {
        if (window.jsonSourceEditor) {
            window.jsonSourceEditor.setValue(value || '');
        } else {
            document.getElementById('json_source').value = value || '';
        }
        updateStats('json_source');
    }
    function getJsonTarget() {
        return window.jsonTargetEditor ? window.jsonTargetEditor.getValue() : document.getElementById('json_target').value;
    }
    function setJsonTarget(value) {
        if (window.jsonTargetEditor) {
            window.jsonTargetEditor.setValue(value || '');
        } else {
            document.getElementById('json_target').value = value || '';
        }
        updateStats('json_target');
    }

    // 切换标签页函数
    function switchTab(targetId) {
        // 更新切换开关状态
        const toggleOptions = document.querySelectorAll('.toggle-option');
        const toggleSlider = document.getElementById('toggleSlider');
        
        toggleOptions.forEach(option => {
            if (option.getAttribute('data-target') === targetId) {
                option.classList.remove('inactive');
                option.classList.add('active');
            } else {
                option.classList.remove('active');
                option.classList.add('inactive');
            }
        });

        // 控制滑动背景（支持多标签）
        const optionArray = Array.from(toggleOptions);
        const currentIndex = optionArray.findIndex(opt => opt.getAttribute('data-target') === targetId);
        const sliderWidthPercent = 100 / optionArray.length;
        const gapPx = 8; // 每段总间隙（左右各 4px）
        toggleSlider.style.width = `calc(${sliderWidthPercent}% - ${gapPx}px)`;
        toggleSlider.style.transform = `translateX(calc(${currentIndex * 100}% + ${currentIndex * gapPx}px))`;

        // 隐藏所有标签页内容
        const tabPanes = document.querySelectorAll('.tab-pane');
        tabPanes.forEach(pane => {
            pane.classList.remove('show', 'active');
        });

        // 显示目标标签页内容
        const targetPane = document.getElementById(targetId);
        if (targetPane) {
            targetPane.classList.add('show', 'active');
        }
    }

    function getTargetText() {
        const target = document.getElementById('target');
        return target.textContent || target.innerText || '';
    }

    function setTargetText(text) {
        const target = document.getElementById('target');
        target.textContent = text;
        updateStats('target');
    }

    function setTargetHTML(html) {
        const target = document.getElementById('target');
        target.innerHTML = html;
        updateStats('target');
    }

    function doClear() {
        document.getElementById('source').value = '';
        setTargetText('');
        updateStats('source');
    }

    function doJsonClear() {
        setJsonSource('');
        setJsonTarget('');
    }

    function overwrite() {
        document.getElementById('source').value = getTargetText();
        updateStats('source');
    }

    function overwriteJson() {
        setJsonSource(getJsonTarget());
    }

    function mergeSymbol(symbolToken) {
        let symbol = '';
        if (symbolToken === 'single') {
            symbol = "'";
        } else if (symbolToken === 'double') {
            symbol = '"';
        }
        const lines = document.getElementById('source').value.trim().split('\n').map(item => item.trim()).filter(item => item !== '');
        setTargetText(lines.map(item => `${symbol}${item}${symbol}`).join(','));
    }

    function wordFrequency() {
        const lines = document.getElementById('source').value.trim().split('\n').map(item => item.trim()).filter(item => item !== '');
        const freqMap = {};
        lines.forEach(line => {
            freqMap[line] = (freqMap[line] || 0) + 1;
        });
        // 按词频降序排序，词频相同时按词的字母顺序排序
        const sortedFreqMap = {};
        Object.entries(freqMap)
            .sort((a, b) => {
                if (b[1] !== a[1]) {
                    return b[1] - a[1];
                } else {
                    return a[0].localeCompare(b[0]);
                }
            })
            .forEach(([key, value]) => {
                sortedFreqMap[key] = value;
            });
        // 以 JSON 格式展示结果，带缩进
        setTargetText(JSON.stringify(sortedFreqMap, null, 4));
    }

    // 修改 splitlines 函数定义以支持分隔符参数
    function splitlines(delimiter) {
        // 按指定分隔符分割文本
        const source = document.getElementById('source').value.trim();
        const lines = source.split(delimiter)
            .map(item => item.trim())
            .filter(item => item !== '');
        setTargetText(lines.join('\n'));
    }

    function distinct() {
        const lines = document.getElementById('source').value.trim().split('\n').map(item => item.trim()).filter(item => item !== '');
        setTargetText([...new Set(lines)].join('\n'));
    }

    // 文本过滤：支持与或非逻辑表达式
    (function() {
        const txtFilterBtn = document.getElementById('txtFilterBtn');
        const textFilterInput = document.getElementById('textFilterInput');
        const toggleCaseBtn = document.getElementById('toggleCaseBtn');

        if (!txtFilterBtn || !textFilterInput || !toggleCaseBtn) return;

        window.textFilterCaseSensitive = false;

        function parseLogicalExpression(expr) {
            const tokens = [];
            let i = 0;
            
            while (i < expr.length) {
                const char = expr[i];
                
                if (/\s/.test(char)) {
                    i++;
                    continue;
                }
                
                if (char === '(' || char === ')' || char === '!' || char === '&' || char === '|') {
                    tokens.push(char);
                    i++;
                } else {
                    let token = '';
                    while (i < expr.length && !/[\s()&|!]/.test(expr[i])) {
                        token += expr[i];
                        i++;
                    }
                    if (token) {
                        tokens.push(token);
                    }
                }
            }
            
            return tokens;
        }

        function buildAST(tokens) {
            let pos = 0;
            
            function parseExpression() {
                return parseOr();
            }
            
            function parseOr() {
                let left = parseAnd();
                while (pos < tokens.length && tokens[pos] === '|') {
                    pos++;
                    if (pos < tokens.length && tokens[pos] === '|') {
                        pos++;
                    }
                    // 检查是否有右侧操作数
                    if (pos >= tokens.length) {
                        // 如果没有右侧操作数，返回左侧操作数
                        return left;
                    }
                    const right = parseAnd();
                    left = { type: 'or', left, right };
                }
                return left;
            }
            
            function parseAnd() {
                let left = parseNot();
                while (pos < tokens.length && tokens[pos] === '&') {
                    pos++;
                    if (pos < tokens.length && tokens[pos] === '&') {
                        pos++;
                    }
                    // 检查是否有右侧操作数
                    if (pos >= tokens.length) {
                        // 如果没有右侧操作数，返回左侧操作数
                        return left;
                    }
                    const right = parseNot();
                    left = { type: 'and', left, right };
                }
                return left;
            }
            
            function parseNot() {
                if (pos < tokens.length && tokens[pos] === '!') {
                    pos++;
                    const operand = parsePrimary();
                    return { type: 'not', operand };
                }
                return parsePrimary();
            }
            
            function parsePrimary() {
                if (pos < tokens.length && tokens[pos] === '(') {
                    pos++;
                    const expr = parseExpression();
                    if (pos < tokens.length && tokens[pos] === ')') {
                        pos++;
                    }
                    return expr;
                }
                if (pos < tokens.length) {
                    const token = tokens[pos];
                    pos++;
                    return { type: 'literal', value: token };
                }
                return { type: 'literal', value: '' };
            }
            
            return parseExpression();
        }

        function evaluateAST(ast, line) {
            if (!ast) return { matched: true, matchedTokens: [] };
            
            switch (ast.type) {
                case 'or':
                    const leftResult = evaluateAST(ast.left, line);
                    const rightResult = evaluateAST(ast.right, line);
                    if (leftResult.matched || rightResult.matched) {
                        return { matched: true, matchedTokens: [...leftResult.matchedTokens, ...rightResult.matchedTokens] };
                    }
                    return { matched: false, matchedTokens: [] };
                case 'and':
                    const leftResultAnd = evaluateAST(ast.left, line);
                    const rightResultAnd = evaluateAST(ast.right, line);
                    if (leftResultAnd.matched && rightResultAnd.matched) {
                        return { matched: true, matchedTokens: [...leftResultAnd.matchedTokens, ...rightResultAnd.matchedTokens] };
                    }
                    return { matched: false, matchedTokens: [] };
                case 'not':
                    const operandResult = evaluateAST(ast.operand, line);
                    return { matched: !operandResult.matched, matchedTokens: [] };
                case 'literal':
                    if (window.textFilterCaseSensitive) {
                        const matched = line.includes(ast.value);
                        return { matched, matchedTokens: matched ? [ast.value] : [] };
                    }
                    const matched = line.toLowerCase().includes(ast.value.toLowerCase());
                    return { matched, matchedTokens: matched ? [ast.value] : [] };
                default:
                    return { matched: true, matchedTokens: [] };
            }
        }

        function runTextFilter() {
            const rawValue = document.getElementById('source').value;
            const rawLines = rawValue.split('\n');
            const handled = rawLines.map(item => item.trim()).filter(item => item !== '');
            const expression = textFilterInput.value || '';

            let result;
            if (!expression.trim()) {
                result = handled.map(line => ({ text: line, matched: false, matchedTokens: [] }));
            } else {
                try {
                    const tokens = parseLogicalExpression(expression);
                    // 检查是否存在不完整的表达式（例如 'apple ||' 或 '(apple || banana) && !'）
                    if (tokens.length > 0) {
                        // 检查是否有不完整的操作符在末尾
                        if (tokens[tokens.length - 1] === '|' || tokens[tokens.length - 1] === '&') {
                            // 如果最后一个token是操作符，则移除它
                            tokens.pop();
                        } else if (tokens[tokens.length - 1] === '!') {
                            // 如果最后一个token是'!'，也需要移除它，因为它是一元操作符但没有操作数
                            tokens.pop();
                        }
                    }
                    const ast = buildAST(tokens);
                    result = handled.map(line => {
                        const evalResult = evaluateAST(ast, line);
                        return { text: line, matched: evalResult.matched, matchedTokens: evalResult.matchedTokens };
                    }).filter(item => item.matched);
                } catch (error) {
                    result = handled.map(line => ({ text: line, matched: false, matchedTokens: [] }));
                }
            }
            
            const targetEl = document.getElementById('target');
            const htmlContent = result.map(item => {
                let text = item.text;
                
                // 转义HTML特殊字符（但保留已有的HTML标签）
                const escapedText = text.replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;');
                
                // 分割HTML标签和文本内容
                const parts = [];
                let lastIndex = 0;
                const tagRegex = /&lt;[^&gt;]+&gt;/g;
                let match;
                
                while ((match = tagRegex.exec(escapedText)) !== null) {
                    if (match.index > lastIndex) {
                        parts.push({ type: 'text', content: escapedText.substring(lastIndex, match.index) });
                    }
                    // 将转义的HTML标签还原
                    const originalTag = match[0].replace(/&lt;/g, '<').replace(/&gt;/g, '>');
                    parts.push({ type: 'tag', content: originalTag });
                    lastIndex = match.index + match[0].length;
                }
                
                if (lastIndex < escapedText.length) {
                    parts.push({ type: 'text', content: escapedText.substring(lastIndex) });
                }
                
                // 只在文本部分进行高亮
                const highlightedParts = parts.map(part => {
                    if (part.type === 'tag') {
                        return part.content;
                    } else {
                        let highlightedText = part.content;
                        item.matchedTokens.forEach(token => {
                            if (window.textFilterCaseSensitive) {
                                highlightedText = highlightedText.replace(new RegExp(`(${escapeRegExp(token)})`, 'g'), '<span class="filter-highlight">$1</span>');
                            } else {
                                highlightedText = highlightedText.replace(new RegExp(`(${escapeRegExp(token)})`, 'gi'), '<span class="filter-highlight">$1</span>');
                            }
                        });
                        return highlightedText;
                    }
                });
                
                return highlightedParts.join('');
            }).join('<br>');
            setTargetHTML(htmlContent);
        }

        function escapeRegExp(string) {
            return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }

        textFilterInput.addEventListener('input', runTextFilter);
        toggleCaseBtn.addEventListener('click', function() {
            window.textFilterCaseSensitive = !window.textFilterCaseSensitive;
            toggleCaseBtn.classList.toggle('active', window.textFilterCaseSensitive);
            runTextFilter();
        });
    })();

    function ascending() {
        const lines = document.getElementById('source').value.trim().split('\n').map(item => item.trim()).filter(item => item !== '');

        const sortedElements = lines.sort((a, b) => {
            const isNumericA = !isNaN(parseFloat(a)) && isFinite(parseFloat(a));
            const isNumericB = !isNaN(parseFloat(b)) && isFinite(parseFloat(b));

            if (isNumericA && isNumericB) {
                return parseFloat(a) - parseFloat(b);
            } else {
                return a.localeCompare(b);
            }
        });
        setTargetText(sortedElements.join('\n'));
    }

    function descending() {
        const lines = document.getElementById('source').value.trim().split('\n').map(item => item.trim()).filter(item => item !== '');

        const sortedElements = lines.sort((a, b) => {
            const isNumericA = !isNaN(parseFloat(a)) && isFinite(parseFloat(a));
            const isNumericB = !isNaN(parseFloat(b)) && isFinite(parseFloat(b));

            if (isNumericA && isNumericB) {
                return parseFloat(b) - parseFloat(a);
            } else {
                return b.localeCompare(a);
            }
        });
        setTargetText(sortedElements.join('\n'));
    }

    function sum() {
        const lines = document.getElementById('source').value.trim().split('\n').map(item => item.trim()).filter(item => item !== '');
        const numbers = lines.map(item => parseFloat(item)).filter(item => !isNaN(item));
        
        if (numbers.length === 0) {
            setTargetText('没有有效的数字');
            return;
        }
        
        const total = numbers.reduce((acc, num) => acc + num, 0);
        
        setTargetText(total.toString());
    }

    function average() {
        const lines = document.getElementById('source').value.trim().split('\n').map(item => item.trim()).filter(item => item !== '');
        const numbers = lines.map(item => parseFloat(item)).filter(item => !isNaN(item));
        
        if (numbers.length === 0) {
            setTargetText('没有有效的数字');
            return;
        }
        
        const sum = numbers.reduce((acc, num) => acc + num, 0);
        const avg = sum / numbers.length;
        
        setTargetText(avg.toString());
    }

    function reverse() {
        setTargetText(document.getElementById("source").value.split('').reverse().join(''));
    }

    function toUpperCase() {
        setTargetText(document.getElementById("source").value.toUpperCase());
    }

    function toLowerCase() {
        setTargetText(document.getElementById("source").value.toLowerCase());
    }

    function toCamelCase() {
        setTargetText(document.getElementById("source").value.replace(/(_\w)/g, function (m) {
            return m[1].toUpperCase();
        }));
    }

    function toSnakeCase() {
        setTargetText(document.getElementById("source").value.replace(/[A-Z]/g, (match) => `_${match.toLowerCase()}`));
    }

    function base64Encode() {
        setTargetText(btoa(document.getElementById("source").value));
    }

    function base64Decode() {
        setTargetText(atob(document.getElementById("source").value));
    }

    function urlEncode() {
        setTargetText(encodeURIComponent(document.getElementById("source").value));
    }

    function urlDecode() {
        setTargetText(decodeURIComponent(document.getElementById("source").value));
    }

    async function switchToExtractMode() {
        // 切换到提取列模式
        document.getElementById('filterInputGroup').style.display = 'none';
        document.getElementById('replaceInputGroup').style.display = 'none';
        document.getElementById('joinInputGroup').style.display = 'none';
        document.getElementById('extractInputGroup').style.display = 'flex';
        document.getElementById('toggleCaseBtn').style.display = 'none';
        document.getElementById('txtFilterBtn').textContent = '提取';
        
        // 更新tooltip提示信息
        const btn = document.getElementById('txtFilterBtn');
        btn.setAttribute('title', '提取指定列，支持自定义分割符和多列提取');
        
        // 重新初始化tooltip
        $(btn).tooltip('dispose');
        $(btn).tooltip();
        
        // 添加实时提取事件监听器
        const delimiterInput = document.getElementById('extractDelimiter');
        const columnsInput = document.getElementById('extractColumns');
        
        delimiterInput.addEventListener('input', doExtractColumns);
        columnsInput.addEventListener('input', doExtractColumns);
        
        // 初始执行一次提取
        doExtractColumns();
    }
    
    async function switchToReplaceMode() {
        // 切换到替换模式
        document.getElementById('filterInputGroup').style.display = 'none';
        document.getElementById('extractInputGroup').style.display = 'none';
        document.getElementById('joinInputGroup').style.display = 'none';
        document.getElementById('replaceInputGroup').style.display = 'flex';
        document.getElementById('toggleCaseBtn').style.display = 'none';
        document.getElementById('txtFilterBtn').textContent = '替换';
        
        // 更新tooltip提示信息
        const btn = document.getElementById('txtFilterBtn');
        btn.setAttribute('title', '替换文本内容');
        
        // 重新初始化tooltip
        $(btn).tooltip('dispose');
        $(btn).tooltip();
        
        // 添加实时替换事件监听器
        const replaceFromInput = document.getElementById('replaceFrom');
        const replaceToInput = document.getElementById('replaceTo');
        
        replaceFromInput.addEventListener('input', doReplace);
        replaceToInput.addEventListener('input', doReplace);
        
        // 初始执行一次替换
        doReplace();
    }
    
    async function switchToJoinMode() {
        // 切换到拼接模式
        document.getElementById('filterInputGroup').style.display = 'none';
        document.getElementById('extractInputGroup').style.display = 'none';
        document.getElementById('replaceInputGroup').style.display = 'none';
        document.getElementById('joinInputGroup').style.display = 'flex';
        document.getElementById('toggleCaseBtn').style.display = 'none';
        document.getElementById('txtFilterBtn').textContent = '拼接';
        
        // 更新tooltip提示信息
        const btn = document.getElementById('txtFilterBtn');
        btn.setAttribute('title', '拼接文本前缀和后缀');
        
        // 重新初始化tooltip
        $(btn).tooltip('dispose');
        $(btn).tooltip();
        
        // 添加实时拼接事件监听器
        const joinPrefixInput = document.getElementById('joinPrefix');
        const joinSuffixInput = document.getElementById('joinSuffix');
        
        joinPrefixInput.addEventListener('input', doJoin);
        joinSuffixInput.addEventListener('input', doJoin);
        
        // 初始执行一次拼接
        doJoin();
    }
    
    async function switchToFilterMode() {
        // 切换回过滤模式
        document.getElementById('extractInputGroup').style.display = 'none';
        document.getElementById('replaceInputGroup').style.display = 'none';
        document.getElementById('joinInputGroup').style.display = 'none';
        document.getElementById('filterInputGroup').style.display = 'flex';
        document.getElementById('toggleCaseBtn').style.display = 'block';
        document.getElementById('txtFilterBtn').textContent = '过滤';
        
        // 更新tooltip提示信息
        const btn = document.getElementById('txtFilterBtn');
        btn.setAttribute('title', '多行文本过滤 支持逻辑表达式: || 或, && 与, ! 非, () 分组');
        
        // 重新初始化tooltip
        $(btn).tooltip('dispose');
        $(btn).tooltip();
    }
    
    function doExtractColumns() {
        // 执行提取列操作
        const delimiter = document.getElementById('extractDelimiter').value;
        const columnsInput = document.getElementById('extractColumns').value;
        
        // 只有当用户输入了列号时，才检查是否有分隔符
        if (columnsInput) {
            if (!delimiter) {
                return;
            }
            
            // 解析列号
            const columns = columnsInput.split(',').map(col => parseInt(col.trim()) - 1).filter(col => !isNaN(col) && col >= 0);
            if (columns.length === 0) {
                return;
            }
            
            // 处理文本
            const source = document.getElementById('source').value;
            const lines = source.split('\n');
            
            const result = lines.map(line => {
                const parts = line.split(delimiter);
                return columns.map(col => parts[col] || '').join(delimiter);
            }).filter(line => line.trim() !== '');
            
            setTargetText(result.join('\n'));
        }
    }
    
    function doReplace() {
        // 执行替换操作
        const replaceFrom = document.getElementById('replaceFrom').value;
        const replaceTo = document.getElementById('replaceTo').value;
        
        // 只有当用户输入了要替换的内容时，才执行替换
        if (replaceFrom) {
            // 处理文本
            const source = document.getElementById('source').value;
            const result = source.replace(new RegExp(replaceFrom.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g'), replaceTo);
            
            setTargetText(result);
        } else {
            // 如果没有输入要替换的内容，显示原始文本
            const source = document.getElementById('source').value;
            setTargetText(source);
        }
    }
    
    function doJoin() {
        // 执行拼接操作
        const prefix = document.getElementById('joinPrefix').value;
        const suffix = document.getElementById('joinSuffix').value;
        
        // 处理文本
        const source = document.getElementById('source').value;
        const lines = source.split('\n');
        
        const result = lines.map(line => {
            return prefix + line + suffix;
        }).filter(line => line.trim() !== prefix + suffix);
        
        setTargetText(result.join('\n'));
    }

    function toTimestamp() {
        let dateString = document.getElementById("source").value;
        if (!dateString) {
            const now = new Date();
            const year = now.getFullYear();
            const month = String(now.getMonth() + 1).padStart(2, '0'); // 月份从0开始，需要加1
            const day = String(now.getDate()).padStart(2, '0');
            const hours = String(now.getHours()).padStart(2, '0');
            const minutes = String(now.getMinutes()).padStart(2, '0');
            const seconds = String(now.getSeconds()).padStart(2, '0');

            dateString = `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
            document.getElementById("source").value = dateString;
        }
        // 使用正则表达式匹配不同的日期格式
        const regexSimple = /^\d{8}$/;
        if (regexSimple.test(dateString)) {
            const year = dateString.slice(0, 4);
            const month = dateString.slice(4, 6);
            const day = dateString.slice(6, 8);

            const date = new Date(`${year}-${month}-${day}`);
            setTargetText(Math.floor(date.getTime() / 1000));
        } else {
            const regex = /(\d{4})[-/年](\d{1,2})[-/月](\d{1,2})(?:日)?(?:\s(\d{1,2}):(\d{1,2}):(\d{1,2}))?/;
            const match = dateString.match(regex);

            if (!match) {
                throw new Error('Invalid date format');
            }

            const [, year, month, day, hour = '00', minute = '00', second = '00'] = match;
            const date = new Date(`${year}-${month}-${day} ${hour}:${minute}:${second}`);

            if (isNaN(date.getTime())) {
                throw new Error('Invalid date');
            }

            setTargetText(Math.floor(date.getTime() / 1000));
        }
    }

    function toDate() {
        let timestamp = document.getElementById("source").value;
        if (!timestamp) {
            timestamp = Math.floor(Date.now() / 1000);
            document.getElementById("source").value = timestamp;
        }
        const timestampInMilliseconds = timestamp < 10000000000 ? timestamp * 1000 : timestamp;
        const date = new Date(timestampInMilliseconds);

        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        const hours = String(date.getHours()).padStart(2, '0');
        const minutes = String(date.getMinutes()).padStart(2, '0');
        const seconds = String(date.getSeconds()).padStart(2, '0');
        const milliseconds = String(date.getMilliseconds()).padStart(3, '0');

        const formattedDates = [
            `${year}-${month}-${day}`,
            `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`,
            `${year}-${month}-${day} ${hours}:${minutes}:${seconds}.${milliseconds}`,
            `${year}/${month}/${day}`,
            `${year}/${month}/${day} ${hours}:${minutes}:${seconds}`,
            `${year}/${month}/${day} ${hours}:${minutes}:${seconds}.${milliseconds}`,
            `${year}年${month}月${day}日`,
            `${year}年${month}月${day}日 ${hours}时${minutes}分${seconds}秒`,
            `${year}年${month}月${day}日 ${hours}时${minutes}分${seconds}秒${milliseconds}毫秒`
        ];

        setTargetText(formattedDates.join('\n'));
    }

    function calculator() {
        setTargetText(eval(document.getElementById("source").value));
    }

    function jsonUnfold() {
        let data = JSON.parse(getJsonSource());
        setJsonTarget(JSON.stringify(data, null, 4));
    }

    function jsonFold() {
        let data = JSON.parse(getJsonSource());
        setJsonTarget(JSON.stringify(data, null, 0));
    }

    // JSON 格式化：读取左侧，格式化后覆盖写回左侧
    function jsonFormat() {
        try {
            const input = getJsonSource();
            if (!input || input.trim() === '') {
                setJsonSource('');
                return;
            }
            const data = JSON.parse(input);
            setJsonSource(JSON.stringify(data, null, 2));
        } catch (error) {
            setJsonSource('错误: ' + error.message);
        }
    }

    function s2ab(s) {
        const buf = new ArrayBuffer(s.length);
        const view = new Uint8Array(buf);
        for (let i = 0; i < s.length; i++) view[i] = s.charCodeAt(i) & 0xFF;
        return buf;
    }

    function jsonToExcel() {
        const json = getJsonSource();
        if (!json.startsWith("[")) {
            alert("请输入 JSON 数组");
            return;
        }
        let data = JSON.parse(json);
        let isEleArray = false;
        if (data.length > 0 && typeof data[0] !== "object") {
            let newJsonArray = [];
            for (let i = 0; i < data.length; i++) {
                newJsonArray.push({"key": data[i]});
            }
            data = newJsonArray;
            isEleArray = true;
        }
        const ws = isEleArray ? XLSX.utils.json_to_sheet(data, {skipHeader: true}) : XLSX.utils.json_to_sheet(data);
        const wb = XLSX.utils.book_new();
        XLSX.utils.book_append_sheet(wb, ws, "Sheet1");
        const wbout = XLSX.write(wb, {bookType: 'xlsx', type: 'binary'});
        saveAs(new Blob([s2ab(wbout)], {type: "application/octet-stream"}), 'output.xlsx');
    }

    document.getElementById("file").addEventListener("change", handleFileChange);

    function handleFileChange(event) {
        document.getElementById("fileLabel").innerHTML = event.target.files[0].name;
        const file = event.target.files[0];
        const reader = new FileReader();
        reader.onload = function (e) {
            const data = e.target.result;
            const workbook = XLSX.read(data, {type: 'binary'});
            const sheetName = workbook.SheetNames[0];
            const sheet = workbook.Sheets[sheetName];
            let json = XLSX.utils.sheet_to_json(sheet);
            if (json.length > 0 && Object.keys(json[0]).length === 1) {
                const colKey = Object.keys(json[0])[0];
                json.forEach(function (item, index) {
                    json[index] = item[Object.keys(item)[0]];
                });
                if (!isNaN(colKey)) {
                    json.unshift(parseInt(colKey));
                } else {
                    json.unshift(colKey);
                }
            }
            setJsonSource(JSON.stringify(json, null, 4));
        };
        reader.readAsArrayBuffer(file);
    }

    document.getElementById("mfile").addEventListener("change", handleMFileChange);

    function handleMFileChange(event) {
        document.getElementById("mfileLabel").innerHTML = Array.from(event.target.files).map(file => file.name).join(', ');
        let mergedData = [];
        let allFilesRead = 0;
        const totalFiles = event.target.files.length;

        Array.from(event.target.files).forEach(file => {
            const reader = new FileReader();
            reader.onload = function (e) {
                const data = e.target.result;
                const workbook = XLSX.read(data, {type: 'binary'});
                const sheetName = workbook.SheetNames[0];
                const sheet = workbook.Sheets[sheetName];
                let jsonData = XLSX.utils.sheet_to_json(sheet);
                mergedData = mergedData.concat(jsonData);
                allFilesRead++;

                if (allFilesRead === totalFiles) {
                    if (mergedData.length > 0 && Object.keys(mergedData[0]).length === 1) {
                        const colKey = Object.keys(mergedData[0])[0];
                        mergedData.forEach(function (item, index) {
                            mergedData[index] = item[Object.keys(item)[0]];
                        });
                        if (!isNaN(colKey)) {
                            mergedData.unshift(parseInt(colKey));
                        } else {
                            mergedData.unshift(colKey);
                        }
                    }
                    setJsonSource(JSON.stringify(mergedData, null, 4));

                    const ws = XLSX.utils.json_to_sheet(mergedData);
                    const wb = XLSX.utils.book_new();
                    XLSX.utils.book_append_sheet(wb, ws, "Sheet1");
                    const wbout = XLSX.write(wb, {bookType: 'xlsx', type: 'binary'});
                    saveAs(new Blob([s2ab(wbout)], {type: "application/octet-stream"}), 'merged_output.xlsx');
                }
            };
            reader.readAsArrayBuffer(file);
        });
    }

    // 文本框统计：行数与字符数
    function computeStats(text) {
        if (text === '') return { lines: 0, chars: 0 };
        const lines = text.split('\n').length;
        const chars = text.length;
        return { lines: lines, chars: chars };
    }

    function renderStats(idPrefix) {
        const textarea = document.getElementById(idPrefix);
        const statsEl = document.getElementById(idPrefix + '-stats');
        if (!statsEl) return;
        let text = '';
        if (idPrefix === 'json_source' && window.jsonSourceEditor) {
            text = window.jsonSourceEditor.getValue();
        } else if (idPrefix === 'json_target' && window.jsonTargetEditor) {
            text = window.jsonTargetEditor.getValue();
        } else if (idPrefix === 'target') {
            text = textarea.textContent || textarea.innerText;
        } else if (textarea) {
            text = textarea.value;
        }
        const { lines, chars } = computeStats(text);
        statsEl.textContent = `${lines} 行 · ${chars} 字符`;
    }

    function updateStats(idPrefix) {
        renderStats(idPrefix);
    }

    // 绑定输入事件，实时更新
    ['source', 'target', 'json_source', 'json_target', 'set-tab-source-1', 'set-tab-source-2', 'set-tab-target-1', 'set-tab-target-2', 'set-tab-target-3', 'set-tab-target-4'].forEach(function (id) {
        const el = document.getElementById(id);
        if (el) {
            el.addEventListener('input', function () { updateStats(id); });
        }
    });

    // 首次渲染
    updateStats('source');
    updateStats('target');
    updateStats('json_source');
    updateStats('json_target');
    updateStats('set-tab-source-1');
    updateStats('set-tab-source-2');
    updateStats('set-tab-target-1');
    updateStats('set-tab-target-2');
    updateStats('set-tab-target-3');
    updateStats('set-tab-target-4');

    // 仅为业务按钮接入遥测（已移除主题按钮，无需排除）
    document.querySelectorAll('button').forEach(function (button) {
        button.addEventListener('click', handleClick);
    });

    // 跟随系统主题：初始化并监听变化
    (function() {
        const mq = window.matchMedia ? window.matchMedia('(prefers-color-scheme: dark)') : null;
        function apply(theme) { document.documentElement.setAttribute('data-theme', theme); }
        const initial = mq && mq.matches ? 'dark' : 'light';
        apply(initial);
        if (mq && typeof mq.addEventListener === 'function') {
            mq.addEventListener('change', function(e) { apply(e.matches ? 'dark' : 'light'); });
        } else if (mq && typeof mq.addListener === 'function') { // 兼容旧浏览器
            mq.addListener(function(e) { apply(e.matches ? 'dark' : 'light'); });
        }
    })();

    // 新增jsonUnescape函数处理逻辑
    function jsonUnescape() {
        try {
            const input = getJsonSource();
            // 处理双重转义的JSON字符串
            let result;
            try {
                // 先尝试直接解析
                result = JSON.parse(input);
            } catch (e) {
                // 如果失败尝试二次解析（处理双重转义场景）
                result = JSON.parse(JSON.parse(`"${input}"`));
            }
            setJsonTarget(JSON.stringify(result, null, 2));
        } catch (error) {
            // 符合错误处理规范 - 显示具体错误信息
            setJsonTarget(`解析失败: ${error.message}`);
            console.error('JSON转义错误:', error);
        }
    }

    // 新增JSON反向转义函数
    function escapeJson() {
        try {
            const input = document.getElementById("source").value;
            const escaped = JSON.stringify(input).slice(1, -1);
            setTargetText(escaped);
        } catch (error) {
            setTargetText(`转义失败: ${error.message}`);
            console.error('JSON反向转义错误:', error);
        }
    }

    function setOperation() {
        // 获取输入值并转换为数组
        const aArray = document.getElementById('set-tab-source-1').value.trim().split('\n').map(item => item.trim()).filter(item => item !== '');
        const bArray = document.getElementById('set-tab-source-2').value.trim().split('\n').map(item => item.trim()).filter(item => item !== '');
        
        // 创建Set对象
        const aSet = new Set(aArray);
        const bSet = new Set(bArray);
        
        // 计算并集
        const union = [...new Set([...aArray, ...bArray])];
        
        // 计算交集
        const intersection = aArray.filter(item => bSet.has(item));
        
        // 计算差集 A-B
        const differenceAB = aArray.filter(item => !bSet.has(item));
        
        // 计算差集 B-A
        const differenceBA = bArray.filter(item => !aSet.has(item));
        
        // 升序排序逻辑（复用ascending函数的排序规则）
        const sortArray = (arr) => arr.sort((a, b) => {
            const isNumericA = !isNaN(parseFloat(a)) && isFinite(parseFloat(a));
            const isNumericB = !isNaN(parseFloat(b)) && isFinite(parseFloat(b));

            if (isNumericA && isNumericB) {
                return parseFloat(a) - parseFloat(b);
            } else {
                return a.localeCompare(b);
            }
        });
        
        // 更新结果文本框（排序前先去重）
        document.getElementById('set-tab-target-1').value = sortArray([...new Set(union)]).join('\n');
        document.getElementById('set-tab-target-2').value = sortArray([...new Set(intersection)]).join('\n');
        document.getElementById('set-tab-target-3').value = sortArray([...new Set(differenceAB)]).join('\n');
        document.getElementById('set-tab-target-4').value = sortArray([...new Set(differenceBA)]).join('\n');

        ['set-tab-source-1','set-tab-source-2','set-tab-target-1','set-tab-target-2','set-tab-target-3','set-tab-target-4']
            .forEach(updateStats);
    }

    // 清理旧的 fieldOpt 兼容逻辑，统一用 jsonModeInput + currentJsonMode
    const jsonSourceInput = document.getElementById('json_source');
    if (window.jsonSourceEditor) {
        window.jsonSourceEditor.on('change', function () {
            const jsonModeInput = document.getElementById('jsonModeInput');
            if (jsonModeInput && jsonModeInput.value.trim() !== '') {
                if (window.currentJsonMode === 'field') {
                    updateJsonFieldExtractCombined();
                } else if (window.currentJsonMode === 'jsonpath') {
                    updateJsonPathEval();
                }
            }
        });
    } else if (jsonSourceInput) {
        jsonSourceInput.addEventListener('input', function () {
            const jsonModeInput = document.getElementById('jsonModeInput');
            if (jsonModeInput && jsonModeInput.value.trim() !== '') {
                if (window.currentJsonMode === 'field') {
                    updateJsonFieldExtractCombined();
                } else if (window.currentJsonMode === 'jsonpath') {
                    updateJsonPathEval();
                }
            }
        });
    }

    // JSON模式输入框占位符切换 + 功能联动
    (function() {
        const modeJsonPath = document.getElementById('modeJsonPath');
        const modeFieldExtract = document.getElementById('modeFieldExtract');
        const jsOptBtn = document.getElementById('jsOptBtn');
        const jsonModeInput = document.getElementById('jsonModeInput');
        // 默认模式
        window.currentJsonMode = 'jsonpath';
        if (jsonModeInput) {
            jsonModeInput.addEventListener('input', function() {
                if (window.currentJsonMode === 'jsonpath') {
                    updateJsonPathEval();
                } else if (window.currentJsonMode === 'field') {
                    updateJsonFieldExtractCombined();
                }
            });
        }
        if (modeJsonPath && modeFieldExtract && jsOptBtn && jsonModeInput) {
            modeJsonPath.addEventListener('click', function(e) {
                e.preventDefault();
                jsOptBtn.textContent = 'JSONPath this';
                jsonModeInput.placeholder = '.key.subKey、[0][1]、.map(x=>x.val)、.filer(x=>x.val>20) ';
                window.currentJsonMode = 'jsonpath';
                if (jsonModeInput.value.trim() !== '') {
                    updateJsonPathEval();
                }
            });
            modeFieldExtract.addEventListener('click', function(e) {
                e.preventDefault();
                jsOptBtn.textContent = 'JSONArray extracts';
                jsonModeInput.placeholder = 'key1,key2,key3... ';
                window.currentJsonMode = 'field';
                if (jsonModeInput.value.trim() !== '') {
                    updateJsonFieldExtractCombined();
                }
            });
        }
    })();

    // 模式一：在 json_source 上执行 JS 表达式（以 this 开头）并输出到 json_target
    function updateJsonPathEval() {
        try {
            const exprInputEl = document.getElementById('jsonModeInput');
            if (!exprInputEl) return;
            const expr = exprInputEl.value.trim();
            if (expr === '') return;
            const jsCode = 'this' + expr;
            const sourceText = getJsonSource();
            const jsonData = JSON.parse(sourceText);
            const result = new Function('return ' + jsCode.replace(/^this/, 'arguments[0]'))(jsonData);
            setJsonTarget(JSON.stringify(result, null, 2));
        } catch (error) {
            setJsonTarget('错误: ' + error.message);
        }
    }

    // 模式二：字段提取（从 json_source 的数组元素中提取指定字段）
    function updateJsonFieldExtractCombined() {
        const jsonModeInput = document.getElementById('jsonModeInput');
        if (!jsonModeInput) return;
        const fieldsInput = jsonModeInput.value.trim();
        if (fieldsInput === '') {
            return;
        }
        const fields = fieldsInput.split(',').map(key => key.trim()).filter(key => key.length > 0);
        try {
            const sourceText = getJsonSource();
            const data = JSON.parse(sourceText);
            if (!Array.isArray(data)) {
                throw new Error('请输入 JSON 数组');
            }
            const result = data.map(item => {
                const picked = {};
                if (item && typeof item === 'object') {
                    fields.forEach(key => {
                        if (Object.prototype.hasOwnProperty.call(item, key)) {
                            picked[key] = item[key];
                        }
                    });
                }
                return picked;
            });
            setJsonTarget(JSON.stringify(result, null, 2));
        } catch (error) {
            setJsonTarget('错误: ' + error.message);
        }
    }

    // 大爆炸功能实现
    let bigbangMode = 'word'; // 默认为分词模式
    let selectedWords = [];

    // 监听输入框变化自动处理
    const bigbangInput = document.getElementById('bigbangInput');
    if (bigbangInput) {
        bigbangInput.addEventListener('input', function() {
            const text = this.value;
            if (text.trim()) {
                // 默认激活分词模式
                if (!document.getElementById('splitByWord').classList.contains('active') && 
                    !document.getElementById('splitByChar').classList.contains('active')) {
                    bigbangMode = 'word';
                    document.getElementById('splitByWord').classList.add('active');
                }
                bigbangProcess(text);
            } else {
                document.getElementById('wordContainer').innerHTML = '';
                selectedWords = [];
                updateResult();
                updateBigbangStats();
            }
        });
    }

    // 智能分割函数
    function smartSplit(text) {
        const tokens = [];
        const specialChars = /[\s,;\.:\!\?\(\)\[\]\{\}<>'"/\\。？！，、；："\"'（）【】《》]/;
        const urlRegex = /(https?:\/\/[^\s]+)/g;
        
        // 首先提取URL
        const urls = text.match(urlRegex) || [];
        let textWithoutUrls = text;
        urls.forEach(function(url, index) {
            textWithoutUrls = textWithoutUrls.replace(url, `__URL${index}__`);
        });
        
        let currentToken = '';
        for (let i = 0; i < textWithoutUrls.length; i++) {
            const char = textWithoutUrls[i];
            
            if (specialChars.test(char)) {
                if (currentToken) {
                    tokens.push(currentToken);
                    currentToken = '';
                }
                if (char.trim() !== '') {
                    tokens.push(char);
                }
            } else {
                currentToken += char;
            }
        }
        if (currentToken) {
            tokens.push(currentToken);
        }
        
        // 还原URL
        const finalTokens = [];
        tokens.forEach(function(token) {
            const urlMatch = token.match(/__URL(\d+)__/);
            if (urlMatch) {
                const urlIndex = parseInt(urlMatch[1]);
                finalTokens.push(urls[urlIndex]);
            } else {
                finalTokens.push(token);
            }
        });
        
        return finalTokens;
    }

    // 分词处理
    function bigbangProcess(text) {
        let words = [];
        
        if (bigbangMode === 'word') {
            // 先提取并保护URL
            const urlRegex = /(https?:\/\/[^\s]+)/g;
            const urls = [];
            let textWithPlaceholders = text;
            let match;
            let urlIndex = 0;
            
            while ((match = urlRegex.exec(text)) !== null) {
                urls.push(match[0]);
                textWithPlaceholders = textWithPlaceholders.replace(match[0], `__URL_PLACEHOLDER_${urlIndex}__`);
                urlIndex++;
            }
            
            // 按空格分词，同时分离中英文
            const tokens = textWithPlaceholders.split(/\s+/).filter(function(w) { return w.trim() !== ''; });
            tokens.forEach(function(token) {
                // 检查是否是URL占位符
                const placeholderMatch = token.match(/__URL_PLACEHOLDER_(\d+)__/);
                if (placeholderMatch) {
                    const index = parseInt(placeholderMatch[1]);
                    words.push(urls[index]);
                } else {
                    // 使用正则分离中文、英文、数字
                    const parts = token.match(/[\u4e00-\u9fa5]+|[a-zA-Z]+|[0-9]+|[^\u4e00-\u9fa5a-zA-Z0-9\s]+/g);
                    if (parts) {
                        words = words.concat(parts);
                    } else if (token) {
                        words.push(token);
                    }
                }
            });
        } else if (bigbangMode === 'char') {
            // 按字符分割
            words = text.split('').filter(function(w) { return w.trim() !== ''; });
        }
        
        const container = document.getElementById('wordContainer');
        container.innerHTML = '';
        selectedWords = [];
        
        words.forEach(function(word, index) {
            const tag = document.createElement('span');
            tag.className = 'word-tag';
            tag.textContent = word;
            tag.setAttribute('data-index', index);
            tag.onclick = function() {
                toggleWordSelection(this, word);
            };
            container.appendChild(tag);
        });
        
        updateBigbangStats();
    }

    // 切换单词选中状态
    function toggleWordSelection(element, word) {
        if (element.classList.contains('selected')) {
            element.classList.remove('selected');
            const index = selectedWords.indexOf(word);
            if (index > -1) {
                selectedWords.splice(index, 1);
            }
        } else {
            element.classList.add('selected');
            selectedWords.push(word);
        }
        updateResult();
    }

    // 更新结果显示
    function updateResult() {
        const resultArea = document.getElementById('resultArea');
        resultArea.textContent = selectedWords.join('');
        updateBigbangStats();
    }

    // 更新大爆炸统计
    function updateBigbangStats() {
        const sourceStats = document.getElementById('bigbang-source-stats');
        const targetStats = document.getElementById('bigbang-target-stats');
        const container = document.getElementById('wordContainer');
        const resultArea = document.getElementById('resultArea');
        
        if (sourceStats) {
            const count = container.querySelectorAll('.word-tag').length;
            sourceStats.textContent = count + ' 个元素';
        }
        
        if (targetStats) {
            const text = resultArea.textContent;
            const stats = computeStats(text);
            targetStats.textContent = stats.lines + ' 行 · ' + stats.chars + ' 字符';
        }
    }

    // 切换分割模式
    function bigbangSplitMode(mode) {
        bigbangMode = mode;
        
        // 更新按钮样式
        document.getElementById('splitByWord').classList.remove('active');
        document.getElementById('splitByChar').classList.remove('active');
        
        if (mode === 'word') {
            document.getElementById('splitByWord').classList.add('active');
        } else if (mode === 'char') {
            document.getElementById('splitByChar').classList.add('active');
        }
        
        // 重新处理当前文本
        const input = document.getElementById('bigbangInput');
        if (input && input.value.trim()) {
            bigbangProcess(input.value);
        }
    }

    // 清空选择
    function bigbangClearSelection() {
        const tags = document.querySelectorAll('#wordContainer .word-tag');
        tags.forEach(function(tag) {
            tag.classList.remove('selected');
        });
        selectedWords = [];
        updateResult();
    }

    // 清空所有
    function bigbangClear() {
        document.getElementById('bigbangInput').value = '';
        document.getElementById('wordContainer').innerHTML = '';
        document.getElementById('resultArea').textContent = '';
        selectedWords = [];
        updateBigbangStats();
    }

    // 清空输入框
    function bigbangClearInput() {
        document.getElementById('bigbangInput').value = '';
        document.getElementById('bigbangInput').focus();
    }

    // 复制结果
    function bigbangCopyResult() {
        const result = document.getElementById('resultArea').textContent;
        if (result) {
            navigator.clipboard.writeText(result).then(function() {
                showCopyNotification('复制成功！');
            }).catch(function() {
                // 复制失败，使用备用方法
                const textarea = document.createElement('textarea');
                textarea.value = result;
                document.body.appendChild(textarea);
                textarea.select();
                const success = document.execCommand('copy');
                document.body.removeChild(textarea);
                if (success) {
                    showCopyNotification('复制成功！');
                } else {
                    showCopyNotification('复制失败', true);
                }
            });
        } else {
            showCopyNotification('没有内容可复制', true);
        }
    }
    
    // 显示复制提醒弹窗
    function showCopyNotification(message, isError) {
        // 移除已存在的提示
        const existingNotification = document.getElementById('copyNotification');
        if (existingNotification) {
            existingNotification.remove();
        }
        
        // 创建新提示
        const notification = document.createElement('div');
        notification.id = 'copyNotification';
        notification.textContent = message;
        notification.style.position = 'fixed';
        notification.style.top = '50%';
        notification.style.left = '50%';
        notification.style.transform = 'translate(-50%, -50%)';
        notification.style.padding = '20px 40px';
        notification.style.backgroundColor = '#ffffff';
        notification.style.color = isError ? '#dc3545' : '#333333';
        notification.style.border = '2px solid ' + (isError ? '#dc3545' : '#dee2e6');
        notification.style.borderRadius = '8px';
        notification.style.boxShadow = '0 4px 20px rgba(0, 0, 0, 0.3)';
        notification.style.zIndex = '9999';
        notification.style.fontSize = '16px';
        notification.style.fontWeight = '500';
        notification.style.transition = 'opacity 0.3s ease';
        
        document.body.appendChild(notification);
        
        // 2秒后淡出并移除
        setTimeout(function() {
            notification.style.opacity = '0';
            setTimeout(function() {
                notification.remove();
            }, 300);
        }, 2000);
    }
</script>
</body>
</html>